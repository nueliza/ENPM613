{"ast":null,"code":"var Emitter = require('component-emitter');\n\nvar Response = require('./response').Response;\n\nvar querystring = require('querystring');\n\nvar WebSocket;\nvar createWebSocket;\n\nif (global.WebSocket) {\n  WebSocket = global.WebSocket;\n\n  createWebSocket = function (uri, options) {\n    return new WebSocket(uri);\n  };\n} else {\n  WebSocket = require('ws');\n\n  createWebSocket = function (uri, options) {\n    return new WebSocket(uri, null, options);\n  };\n}\n\nvar scErrors = require('sc-errors');\n\nvar TimeoutError = scErrors.TimeoutError;\nvar BadConnectionError = scErrors.BadConnectionError;\n\nvar SCTransport = function (authEngine, codecEngine, options) {\n  var self = this;\n  this.state = this.CLOSED;\n  this.auth = authEngine;\n  this.codec = codecEngine;\n  this.options = options;\n  this.connectTimeout = options.connectTimeout;\n  this.pingTimeout = options.ackTimeout;\n  this.pingTimeoutDisabled = !!options.pingTimeoutDisabled;\n  this.callIdGenerator = options.callIdGenerator;\n  this.authTokenName = options.authTokenName;\n  this._pingTimeoutTicker = null;\n  this._callbackMap = {};\n  this._batchSendList = []; // Open the connection.\n\n  this.state = this.CONNECTING;\n  var uri = this.uri();\n  var wsSocket = createWebSocket(uri, this.options);\n  wsSocket.binaryType = this.options.binaryType;\n  this.socket = wsSocket;\n\n  wsSocket.onopen = function () {\n    self._onOpen();\n  };\n\n  wsSocket.onclose = function (event) {\n    var code;\n\n    if (event.code == null) {\n      // This is to handle an edge case in React Native whereby\n      // event.code is undefined when the mobile device is locked.\n      // TODO: This is not perfect since this condition could also apply to\n      // an abnormal close (no close control frame) which would be a 1006.\n      code = 1005;\n    } else {\n      code = event.code;\n    }\n\n    self._onClose(code, event.reason);\n  };\n\n  wsSocket.onmessage = function (message, flags) {\n    self._onMessage(message.data);\n  };\n\n  wsSocket.onerror = function (error) {\n    // The onclose event will be called automatically after the onerror event\n    // if the socket is connected - Otherwise, if it's in the middle of\n    // connecting, we want to close it manually with a 1006 - This is necessary\n    // to prevent inconsistent behavior when running the client in Node.js\n    // vs in a browser.\n    if (self.state === self.CONNECTING) {\n      self._onClose(1006);\n    }\n  };\n\n  this._connectTimeoutRef = setTimeout(function () {\n    self._onClose(4007);\n\n    self.socket.close(4007);\n  }, this.connectTimeout);\n};\n\nSCTransport.prototype = Object.create(Emitter.prototype);\nSCTransport.CONNECTING = SCTransport.prototype.CONNECTING = 'connecting';\nSCTransport.OPEN = SCTransport.prototype.OPEN = 'open';\nSCTransport.CLOSED = SCTransport.prototype.CLOSED = 'closed';\n\nSCTransport.prototype.uri = function () {\n  var query = this.options.query || {};\n  var schema = this.options.secure ? 'wss' : 'ws';\n\n  if (this.options.timestampRequests) {\n    query[this.options.timestampParam] = new Date().getTime();\n  }\n\n  query = querystring.encode(query);\n\n  if (query.length) {\n    query = '?' + query;\n  }\n\n  var host;\n\n  if (this.options.host) {\n    host = this.options.host;\n  } else {\n    var port = '';\n\n    if (this.options.port && (schema === 'wss' && this.options.port !== 443 || schema === 'ws' && this.options.port !== 80)) {\n      port = ':' + this.options.port;\n    }\n\n    host = this.options.hostname + port;\n  }\n\n  return schema + '://' + host + this.options.path + query;\n};\n\nSCTransport.prototype._onOpen = function () {\n  var self = this;\n  clearTimeout(this._connectTimeoutRef);\n\n  this._resetPingTimeout();\n\n  this._handshake(function (err, status) {\n    if (err) {\n      var statusCode;\n\n      if (status && status.code) {\n        statusCode = status.code;\n      } else {\n        statusCode = 4003;\n      }\n\n      self._onError(err);\n\n      self._onClose(statusCode, err.toString());\n\n      self.socket.close(statusCode);\n    } else {\n      self.state = self.OPEN;\n      Emitter.prototype.emit.call(self, 'open', status);\n\n      self._resetPingTimeout();\n    }\n  });\n};\n\nSCTransport.prototype._handshake = function (callback) {\n  var self = this;\n  this.auth.loadToken(this.authTokenName, function (err, token) {\n    if (err) {\n      callback(err);\n    } else {\n      // Don't wait for this.state to be 'open'.\n      // The underlying WebSocket (this.socket) is already open.\n      var options = {\n        force: true\n      };\n      self.emit('#handshake', {\n        authToken: token\n      }, options, function (err, status) {\n        if (status) {\n          // Add the token which was used as part of authentication attempt\n          // to the status object.\n          status.authToken = token;\n\n          if (status.authError) {\n            status.authError = scErrors.hydrateError(status.authError);\n          }\n        }\n\n        callback(err, status);\n      });\n    }\n  });\n};\n\nSCTransport.prototype._abortAllPendingEventsDueToBadConnection = function (failureType) {\n  for (var i in this._callbackMap) {\n    if (this._callbackMap.hasOwnProperty(i)) {\n      var eventObject = this._callbackMap[i];\n      delete this._callbackMap[i];\n      clearTimeout(eventObject.timeout);\n      delete eventObject.timeout;\n      var errorMessage = \"Event '\" + eventObject.event + \"' was aborted due to a bad connection\";\n      var badConnectionError = new BadConnectionError(errorMessage, failureType);\n      var callback = eventObject.callback;\n      delete eventObject.callback;\n      callback.call(eventObject, badConnectionError, eventObject);\n    }\n  }\n};\n\nSCTransport.prototype._onClose = function (code, data) {\n  delete this.socket.onopen;\n  delete this.socket.onclose;\n  delete this.socket.onmessage;\n  delete this.socket.onerror;\n  clearTimeout(this._connectTimeoutRef);\n  clearTimeout(this._pingTimeoutTicker);\n  clearTimeout(this._batchTimeout);\n\n  if (this.state === this.OPEN) {\n    this.state = this.CLOSED;\n    Emitter.prototype.emit.call(this, 'close', code, data);\n\n    this._abortAllPendingEventsDueToBadConnection('disconnect');\n  } else if (this.state === this.CONNECTING) {\n    this.state = this.CLOSED;\n    Emitter.prototype.emit.call(this, 'openAbort', code, data);\n\n    this._abortAllPendingEventsDueToBadConnection('connectAbort');\n  }\n};\n\nSCTransport.prototype._handleEventObject = function (obj, message) {\n  if (obj && obj.event != null) {\n    var response = new Response(this, obj.cid);\n    Emitter.prototype.emit.call(this, 'event', obj.event, obj.data, response);\n  } else if (obj && obj.rid != null) {\n    var eventObject = this._callbackMap[obj.rid];\n\n    if (eventObject) {\n      clearTimeout(eventObject.timeout);\n      delete eventObject.timeout;\n      delete this._callbackMap[obj.rid];\n\n      if (eventObject.callback) {\n        var rehydratedError = scErrors.hydrateError(obj.error);\n        eventObject.callback(rehydratedError, obj.data);\n      }\n    }\n  } else {\n    Emitter.prototype.emit.call(this, 'event', 'raw', message);\n  }\n};\n\nSCTransport.prototype._onMessage = function (message) {\n  Emitter.prototype.emit.call(this, 'event', 'message', message);\n  var obj = this.decode(message); // If ping\n\n  if (obj === '#1') {\n    this._resetPingTimeout();\n\n    if (this.socket.readyState === this.socket.OPEN) {\n      this.sendObject('#2');\n    }\n  } else {\n    if (Array.isArray(obj)) {\n      var len = obj.length;\n\n      for (var i = 0; i < len; i++) {\n        this._handleEventObject(obj[i], message);\n      }\n    } else {\n      this._handleEventObject(obj, message);\n    }\n  }\n};\n\nSCTransport.prototype._onError = function (err) {\n  Emitter.prototype.emit.call(this, 'error', err);\n};\n\nSCTransport.prototype._resetPingTimeout = function () {\n  if (this.pingTimeoutDisabled) {\n    return;\n  }\n\n  var self = this;\n  var now = new Date().getTime();\n  clearTimeout(this._pingTimeoutTicker);\n  this._pingTimeoutTicker = setTimeout(function () {\n    self._onClose(4000);\n\n    self.socket.close(4000);\n  }, this.pingTimeout);\n};\n\nSCTransport.prototype.getBytesReceived = function () {\n  return this.socket.bytesReceived;\n};\n\nSCTransport.prototype.close = function (code, data) {\n  code = code || 1000;\n\n  if (this.state === this.OPEN) {\n    var packet = {\n      code: code,\n      data: data\n    };\n    this.emit('#disconnect', packet);\n\n    this._onClose(code, data);\n\n    this.socket.close(code);\n  } else if (this.state === this.CONNECTING) {\n    this._onClose(code, data);\n\n    this.socket.close(code);\n  }\n};\n\nSCTransport.prototype.emitObject = function (eventObject, options) {\n  var simpleEventObject = {\n    event: eventObject.event,\n    data: eventObject.data\n  };\n\n  if (eventObject.callback) {\n    simpleEventObject.cid = eventObject.cid = this.callIdGenerator();\n    this._callbackMap[eventObject.cid] = eventObject;\n  }\n\n  this.sendObject(simpleEventObject, options);\n  return eventObject.cid || null;\n};\n\nSCTransport.prototype._handleEventAckTimeout = function (eventObject) {\n  if (eventObject.cid) {\n    delete this._callbackMap[eventObject.cid];\n  }\n\n  delete eventObject.timeout;\n  var callback = eventObject.callback;\n\n  if (callback) {\n    delete eventObject.callback;\n    var error = new TimeoutError(\"Event response for '\" + eventObject.event + \"' timed out\");\n    callback.call(eventObject, error, eventObject);\n  }\n}; // The last two optional arguments (a and b) can be options and/or callback\n\n\nSCTransport.prototype.emit = function (event, data, a, b) {\n  var self = this;\n  var callback, options;\n\n  if (b) {\n    options = a;\n    callback = b;\n  } else {\n    if (a instanceof Function) {\n      options = {};\n      callback = a;\n    } else {\n      options = a;\n    }\n  }\n\n  var eventObject = {\n    event: event,\n    data: data,\n    callback: callback\n  };\n\n  if (callback && !options.noTimeout) {\n    eventObject.timeout = setTimeout(function () {\n      self._handleEventAckTimeout(eventObject);\n    }, this.options.ackTimeout);\n  }\n\n  var cid = null;\n\n  if (this.state === this.OPEN || options.force) {\n    cid = this.emitObject(eventObject, options);\n  }\n\n  return cid;\n};\n\nSCTransport.prototype.cancelPendingResponse = function (cid) {\n  delete this._callbackMap[cid];\n};\n\nSCTransport.prototype.decode = function (message) {\n  return this.codec.decode(message);\n};\n\nSCTransport.prototype.encode = function (object) {\n  return this.codec.encode(object);\n};\n\nSCTransport.prototype.send = function (data) {\n  if (this.socket.readyState !== this.socket.OPEN) {\n    this._onClose(1005);\n  } else {\n    this.socket.send(data);\n  }\n};\n\nSCTransport.prototype.serializeObject = function (object) {\n  var str, formatError;\n\n  try {\n    str = this.encode(object);\n  } catch (err) {\n    formatError = err;\n\n    this._onError(formatError);\n  }\n\n  if (!formatError) {\n    return str;\n  }\n\n  return null;\n};\n\nSCTransport.prototype.sendObjectBatch = function (object) {\n  var self = this;\n\n  this._batchSendList.push(object);\n\n  if (this._batchTimeout) {\n    return;\n  }\n\n  this._batchTimeout = setTimeout(function () {\n    delete self._batchTimeout;\n\n    if (self._batchSendList.length) {\n      var str = self.serializeObject(self._batchSendList);\n\n      if (str != null) {\n        self.send(str);\n      }\n\n      self._batchSendList = [];\n    }\n  }, this.options.pubSubBatchDuration || 0);\n};\n\nSCTransport.prototype.sendObjectSingle = function (object) {\n  var str = this.serializeObject(object);\n\n  if (str != null) {\n    this.send(str);\n  }\n};\n\nSCTransport.prototype.sendObject = function (object, options) {\n  if (options && options.batch) {\n    this.sendObjectBatch(object);\n  } else {\n    this.sendObjectSingle(object);\n  }\n};\n\nmodule.exports.SCTransport = SCTransport;","map":null,"metadata":{},"sourceType":"script"}