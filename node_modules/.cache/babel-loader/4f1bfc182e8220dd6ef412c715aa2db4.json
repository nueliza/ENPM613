{"ast":null,"code":"var decycle = require('./decycle');\n\nvar isStrict = function () {\n  return !this;\n}();\n\nfunction AuthTokenExpiredError(message, expiry) {\n  this.name = 'AuthTokenExpiredError';\n  this.message = message;\n  this.expiry = expiry;\n\n  if (Error.captureStackTrace && !isStrict) {\n    Error.captureStackTrace(this, arguments.callee);\n  } else {\n    this.stack = new Error().stack;\n  }\n}\n\nAuthTokenExpiredError.prototype = Object.create(Error.prototype);\n\nfunction AuthTokenInvalidError(message) {\n  this.name = 'AuthTokenInvalidError';\n  this.message = message;\n\n  if (Error.captureStackTrace && !isStrict) {\n    Error.captureStackTrace(this, arguments.callee);\n  } else {\n    this.stack = new Error().stack;\n  }\n}\n\nAuthTokenInvalidError.prototype = Object.create(Error.prototype);\n\nfunction AuthTokenNotBeforeError(message, date) {\n  this.name = 'AuthTokenNotBeforeError';\n  this.message = message;\n  this.date = date;\n\n  if (Error.captureStackTrace && !isStrict) {\n    Error.captureStackTrace(this, arguments.callee);\n  } else {\n    this.stack = new Error().stack;\n  }\n}\n\nAuthTokenNotBeforeError.prototype = Object.create(Error.prototype); // For any other auth token error.\n\nfunction AuthTokenError(message) {\n  this.name = 'AuthTokenError';\n  this.message = message;\n\n  if (Error.captureStackTrace && !isStrict) {\n    Error.captureStackTrace(this, arguments.callee);\n  } else {\n    this.stack = new Error().stack;\n  }\n}\n\nAuthTokenError.prototype = Object.create(Error.prototype); // For any other auth error; not specifically related to the auth token itself.\n\nfunction AuthError(message) {\n  this.name = 'AuthError';\n  this.message = message;\n\n  if (Error.captureStackTrace && !isStrict) {\n    Error.captureStackTrace(this, arguments.callee);\n  } else {\n    this.stack = new Error().stack;\n  }\n}\n\nAuthError.prototype = Object.create(Error.prototype);\n\nfunction SilentMiddlewareBlockedError(message, type) {\n  this.name = 'SilentMiddlewareBlockedError';\n  this.message = message;\n  this.type = type;\n\n  if (Error.captureStackTrace && !isStrict) {\n    Error.captureStackTrace(this, arguments.callee);\n  } else {\n    this.stack = new Error().stack;\n  }\n}\n\nSilentMiddlewareBlockedError.prototype = Object.create(Error.prototype);\n\nfunction InvalidActionError(message) {\n  this.name = 'InvalidActionError';\n  this.message = message;\n\n  if (Error.captureStackTrace && !isStrict) {\n    Error.captureStackTrace(this, arguments.callee);\n  } else {\n    this.stack = new Error().stack;\n  }\n}\n\nInvalidActionError.prototype = Object.create(Error.prototype);\n\nfunction InvalidArgumentsError(message) {\n  this.name = 'InvalidArgumentsError';\n  this.message = message;\n\n  if (Error.captureStackTrace && !isStrict) {\n    Error.captureStackTrace(this, arguments.callee);\n  } else {\n    this.stack = new Error().stack;\n  }\n}\n\nInvalidArgumentsError.prototype = Object.create(Error.prototype);\n\nfunction InvalidOptionsError(message) {\n  this.name = 'InvalidOptionsError';\n  this.message = message;\n\n  if (Error.captureStackTrace && !isStrict) {\n    Error.captureStackTrace(this, arguments.callee);\n  } else {\n    this.stack = new Error().stack;\n  }\n}\n\nInvalidOptionsError.prototype = Object.create(Error.prototype);\n\nfunction InvalidMessageError(message) {\n  this.name = 'InvalidMessageError';\n  this.message = message;\n\n  if (Error.captureStackTrace && !isStrict) {\n    Error.captureStackTrace(this, arguments.callee);\n  } else {\n    this.stack = new Error().stack;\n  }\n}\n\nInvalidMessageError.prototype = Object.create(Error.prototype);\n\nfunction SocketProtocolError(message, code) {\n  this.name = 'SocketProtocolError';\n  this.message = message;\n  this.code = code;\n\n  if (Error.captureStackTrace && !isStrict) {\n    Error.captureStackTrace(this, arguments.callee);\n  } else {\n    this.stack = new Error().stack;\n  }\n}\n\nSocketProtocolError.prototype = Object.create(Error.prototype);\n\nfunction ServerProtocolError(message) {\n  this.name = 'ServerProtocolError';\n  this.message = message;\n\n  if (Error.captureStackTrace && !isStrict) {\n    Error.captureStackTrace(this, arguments.callee);\n  } else {\n    this.stack = new Error().stack;\n  }\n}\n\nServerProtocolError.prototype = Object.create(Error.prototype);\n\nfunction HTTPServerError(message) {\n  this.name = 'HTTPServerError';\n  this.message = message;\n\n  if (Error.captureStackTrace && !isStrict) {\n    Error.captureStackTrace(this, arguments.callee);\n  } else {\n    this.stack = new Error().stack;\n  }\n}\n\nHTTPServerError.prototype = Object.create(Error.prototype);\n\nfunction ResourceLimitError(message) {\n  this.name = 'ResourceLimitError';\n  this.message = message;\n\n  if (Error.captureStackTrace && !isStrict) {\n    Error.captureStackTrace(this, arguments.callee);\n  } else {\n    this.stack = new Error().stack;\n  }\n}\n\nResourceLimitError.prototype = Object.create(Error.prototype);\n\nfunction TimeoutError(message) {\n  this.name = 'TimeoutError';\n  this.message = message;\n\n  if (Error.captureStackTrace && !isStrict) {\n    Error.captureStackTrace(this, arguments.callee);\n  } else {\n    this.stack = new Error().stack;\n  }\n}\n\nTimeoutError.prototype = Object.create(Error.prototype);\n\nfunction BadConnectionError(message, type) {\n  this.name = 'BadConnectionError';\n  this.message = message;\n  this.type = type;\n\n  if (Error.captureStackTrace && !isStrict) {\n    Error.captureStackTrace(this, arguments.callee);\n  } else {\n    this.stack = new Error().stack;\n  }\n}\n\nBadConnectionError.prototype = Object.create(Error.prototype);\n\nfunction BrokerError(message) {\n  this.name = 'BrokerError';\n  this.message = message;\n\n  if (Error.captureStackTrace && !isStrict) {\n    Error.captureStackTrace(this, arguments.callee);\n  } else {\n    this.stack = new Error().stack;\n  }\n}\n\nBrokerError.prototype = Object.create(Error.prototype);\n\nfunction ProcessExitError(message, code) {\n  this.name = 'ProcessExitError';\n  this.message = message;\n  this.code = code;\n\n  if (Error.captureStackTrace && !isStrict) {\n    Error.captureStackTrace(this, arguments.callee);\n  } else {\n    this.stack = new Error().stack;\n  }\n}\n\nProcessExitError.prototype = Object.create(Error.prototype);\n\nfunction UnknownError(message) {\n  this.name = 'UnknownError';\n  this.message = message;\n\n  if (Error.captureStackTrace && !isStrict) {\n    Error.captureStackTrace(this, arguments.callee);\n  } else {\n    this.stack = new Error().stack;\n  }\n}\n\nUnknownError.prototype = Object.create(Error.prototype); // Expose all error types.\n\nmodule.exports = {\n  AuthTokenExpiredError: AuthTokenExpiredError,\n  AuthTokenInvalidError: AuthTokenInvalidError,\n  AuthTokenNotBeforeError: AuthTokenNotBeforeError,\n  AuthTokenError: AuthTokenError,\n  AuthError: AuthError,\n  SilentMiddlewareBlockedError: SilentMiddlewareBlockedError,\n  InvalidActionError: InvalidActionError,\n  InvalidArgumentsError: InvalidArgumentsError,\n  InvalidOptionsError: InvalidOptionsError,\n  InvalidMessageError: InvalidMessageError,\n  SocketProtocolError: SocketProtocolError,\n  ServerProtocolError: ServerProtocolError,\n  HTTPServerError: HTTPServerError,\n  ResourceLimitError: ResourceLimitError,\n  TimeoutError: TimeoutError,\n  BadConnectionError: BadConnectionError,\n  BrokerError: BrokerError,\n  ProcessExitError: ProcessExitError,\n  UnknownError: UnknownError\n};\nmodule.exports.socketProtocolErrorStatuses = {\n  1001: 'Socket was disconnected',\n  1002: 'A WebSocket protocol error was encountered',\n  1003: 'Server terminated socket because it received invalid data',\n  1005: 'Socket closed without status code',\n  1006: 'Socket hung up',\n  1007: 'Message format was incorrect',\n  1008: 'Encountered a policy violation',\n  1009: 'Message was too big to process',\n  1010: 'Client ended the connection because the server did not comply with extension requirements',\n  1011: 'Server encountered an unexpected fatal condition',\n  4000: 'Server ping timed out',\n  4001: 'Client pong timed out',\n  4002: 'Server failed to sign auth token',\n  4003: 'Failed to complete handshake',\n  4004: 'Client failed to save auth token',\n  4005: 'Did not receive #handshake from client before timeout',\n  4006: 'Failed to bind socket to message broker',\n  4007: 'Client connection establishment timed out',\n  4008: 'Server rejected handshake from client',\n  4009: 'Server received a message before the client handshake'\n};\nmodule.exports.socketProtocolIgnoreStatuses = {\n  1000: 'Socket closed normally',\n  1001: 'Socket hung up'\n}; // Properties related to error domains cannot be serialized.\n\nvar unserializableErrorProperties = {\n  domain: 1,\n  domainEmitter: 1,\n  domainThrown: 1\n}; // Convert an error into a JSON-compatible type which can later be hydrated\n// back to its *original* form.\n\nmodule.exports.dehydrateError = function dehydrateError(error, includeStackTrace) {\n  var dehydratedError;\n\n  if (error && typeof error === 'object') {\n    dehydratedError = {\n      message: error.message\n    };\n\n    if (includeStackTrace) {\n      dehydratedError.stack = error.stack;\n    }\n\n    for (var i in error) {\n      if (!unserializableErrorProperties[i]) {\n        dehydratedError[i] = error[i];\n      }\n    }\n  } else if (typeof error === 'function') {\n    dehydratedError = '[function ' + (error.name || 'anonymous') + ']';\n  } else {\n    dehydratedError = error;\n  }\n\n  return decycle(dehydratedError);\n}; // Convert a dehydrated error back to its *original* form.\n\n\nmodule.exports.hydrateError = function hydrateError(error) {\n  var hydratedError = null;\n\n  if (error != null) {\n    if (typeof error === 'object') {\n      hydratedError = new Error(error.message);\n\n      for (var i in error) {\n        if (error.hasOwnProperty(i)) {\n          hydratedError[i] = error[i];\n        }\n      }\n    } else {\n      hydratedError = error;\n    }\n  }\n\n  return hydratedError;\n};\n\nmodule.exports.decycle = decycle;","map":null,"metadata":{},"sourceType":"script"}