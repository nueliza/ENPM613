{"ast":null,"code":"var base64Chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar validJSONStartRegex = /^[ \\n\\r\\t]*[{\\[]/;\n\nvar arrayBufferToBase64 = function (arraybuffer) {\n  var bytes = new Uint8Array(arraybuffer);\n  var len = bytes.length;\n  var base64 = '';\n\n  for (var i = 0; i < len; i += 3) {\n    base64 += base64Chars[bytes[i] >> 2];\n    base64 += base64Chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n    base64 += base64Chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n    base64 += base64Chars[bytes[i + 2] & 63];\n  }\n\n  if (len % 3 === 2) {\n    base64 = base64.substring(0, base64.length - 1) + '=';\n  } else if (len % 3 === 1) {\n    base64 = base64.substring(0, base64.length - 2) + '==';\n  }\n\n  return base64;\n};\n\nvar binaryToBase64Replacer = function (key, value) {\n  if (global.ArrayBuffer && value instanceof global.ArrayBuffer) {\n    return {\n      base64: true,\n      data: arrayBufferToBase64(value)\n    };\n  } else if (global.Buffer) {\n    if (value instanceof global.Buffer) {\n      return {\n        base64: true,\n        data: value.toString('base64')\n      };\n    } // Some versions of Node.js convert Buffers to Objects before they are passed to\n    // the replacer function - Because of this, we need to rehydrate Buffers\n    // before we can convert them to base64 strings.\n\n\n    if (value && value.type === 'Buffer' && Array.isArray(value.data)) {\n      var rehydratedBuffer;\n\n      if (global.Buffer.from) {\n        rehydratedBuffer = global.Buffer.from(value.data);\n      } else {\n        rehydratedBuffer = new global.Buffer(value.data);\n      }\n\n      return {\n        base64: true,\n        data: rehydratedBuffer.toString('base64')\n      };\n    }\n  }\n\n  return value;\n}; // Decode the data which was transmitted over the wire to a JavaScript Object in a format which SC understands.\n// See encode function below for more details.\n\n\nmodule.exports.decode = function (input) {\n  if (input == null) {\n    return null;\n  } // Leave ping or pong message as is\n\n\n  if (input === '#1' || input === '#2') {\n    return input;\n  }\n\n  var message = input.toString(); // Performance optimization to detect invalid JSON packet sooner.\n\n  if (!validJSONStartRegex.test(message)) {\n    return message;\n  }\n\n  try {\n    return JSON.parse(message);\n  } catch (err) {}\n\n  return message;\n}; // Encode a raw JavaScript object (which is in the SC protocol format) into a format for\n// transfering it over the wire. In this case, we just convert it into a simple JSON string.\n// If you want to create your own custom codec, you can encode the object into any format\n// (e.g. binary ArrayBuffer or string with any kind of compression) so long as your decode\n// function is able to rehydrate that object back into its original JavaScript Object format\n// (which adheres to the SC protocol).\n// See https://github.com/SocketCluster/socketcluster/blob/master/socketcluster-protocol.md\n// for details about the SC protocol.\n\n\nmodule.exports.encode = function (object) {\n  // Leave ping or pong message as is\n  if (object === '#1' || object === '#2') {\n    return object;\n  }\n\n  return JSON.stringify(object, binaryToBase64Replacer);\n};","map":null,"metadata":{},"sourceType":"script"}