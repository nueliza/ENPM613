{"ast":null,"code":"'use strict';\n/**\n * Constants.\n */\n\nvar errorMessage;\nerrorMessage = 'An argument without append, prepend, ' + 'or detach methods was given to `List';\n/**\n * Creates a new List: A linked list is a bit like an Array, but\n * knows nothing about how many items are in it, and knows only about its\n * first (`head`) and last (`tail`) items. Each item (e.g. `head`, `tail`,\n * &c.) knows which item comes before or after it (its more like the\n * implementation of the DOM in JavaScript).\n * @global\n * @private\n * @constructor\n * @class Represents an instance of List.\n */\n\nfunction List()\n/*items...*/\n{\n  if (arguments.length) {\n    return List.from(arguments);\n  }\n}\n\nvar ListPrototype;\nListPrototype = List.prototype;\n/**\n * Creates a new list from the arguments (each a list item) passed in.\n * @name List.of\n * @param {...ListItem} [items] - Zero or more items to attach.\n * @returns {list} - A new instance of List.\n */\n\nList.of = function ()\n/*items...*/\n{\n  return List.from.call(this, arguments);\n};\n/**\n * Creates a new list from the given array-like object (each a list item)\n * passed in.\n * @name List.from\n * @param {ListItem[]} [items] - The items to append.\n * @returns {list} - A new instance of List.\n */\n\n\nList.from = function (items) {\n  var list = new this(),\n      length,\n      iterator,\n      item;\n\n  if (items && (length = items.length)) {\n    iterator = -1;\n\n    while (++iterator < length) {\n      item = items[iterator];\n\n      if (item !== null && item !== undefined) {\n        list.append(item);\n      }\n    }\n  }\n\n  return list;\n};\n/**\n * List#head\n * Default to `null`.\n */\n\n\nListPrototype.head = null;\n/**\n * List#tail\n * Default to `null`.\n */\n\nListPrototype.tail = null;\n/**\n * Returns the list's items as an array. This does *not* detach the items.\n * @name List#toArray\n * @returns {ListItem[]} - An array of (still attached) ListItems.\n */\n\nListPrototype.toArray = function () {\n  var item = this.head,\n      result = [];\n\n  while (item) {\n    result.push(item);\n    item = item.next;\n  }\n\n  return result;\n};\n/**\n * Prepends the given item to the list: Item will be the new first item\n * (`head`).\n * @name List#prepend\n * @param {ListItem} item - The item to prepend.\n * @returns {ListItem} - An instance of ListItem (the given item).\n */\n\n\nListPrototype.prepend = function (item) {\n  if (!item) {\n    return false;\n  }\n\n  if (!item.append || !item.prepend || !item.detach) {\n    throw new Error(errorMessage + '#prepend`.');\n  }\n\n  var self, head; // Cache self.\n\n  self = this; // If self has a first item, defer prepend to the first items prepend\n  // method, and return the result.\n\n  head = self.head;\n\n  if (head) {\n    return head.prepend(item);\n  } // ...otherwise, there is no `head` (or `tail`) item yet.\n  // Detach the prependee.\n\n\n  item.detach(); // Set the prependees parent list to reference self.\n\n  item.list = self; // Set self's first item to the prependee, and return the item.\n\n  self.head = item;\n  return item;\n};\n/**\n * Appends the given item to the list: Item will be the new last item (`tail`)\n * if the list had a first item, and its first item (`head`) otherwise.\n * @name List#append\n * @param {ListItem} item - The item to append.\n * @returns {ListItem} - An instance of ListItem (the given item).\n */\n\n\nListPrototype.append = function (item) {\n  if (!item) {\n    return false;\n  }\n\n  if (!item.append || !item.prepend || !item.detach) {\n    throw new Error(errorMessage + '#append`.');\n  }\n\n  var self, head, tail; // Cache self.\n\n  self = this; // If self has a last item, defer appending to the last items append\n  // method, and return the result.\n\n  tail = self.tail;\n\n  if (tail) {\n    return tail.append(item);\n  } // If self has a first item, defer appending to the first items append\n  // method, and return the result.\n\n\n  head = self.head;\n\n  if (head) {\n    return head.append(item);\n  } // ...otherwise, there is no `tail` or `head` item yet.\n  // Detach the appendee.\n\n\n  item.detach(); // Set the appendees parent list to reference self.\n\n  item.list = self; // Set self's first item to the appendee, and return the item.\n\n  self.head = item;\n  return item;\n};\n/**\n * Creates a new ListItem: A linked list item is a bit like DOM node:\n * It knows only about its \"parent\" (`list`), the item before it (`prev`),\n * and the item after it (`next`).\n * @global\n * @private\n * @constructor\n * @class Represents an instance of ListItem.\n */\n\n\nfunction ListItem() {}\n\nList.Item = ListItem;\nvar ListItemPrototype = ListItem.prototype;\nListItemPrototype.next = null;\nListItemPrototype.prev = null;\nListItemPrototype.list = null;\n/**\n * Detaches the item operated on from its parent list.\n * @name ListItem#detach\n * @returns {ListItem} - The item operated on.\n */\n\nListItemPrototype.detach = function () {\n  // Cache self, the parent list, and the previous and next items.\n  var self = this,\n      list = self.list,\n      prev = self.prev,\n      next = self.next; // If the item is already detached, return self.\n\n  if (!list) {\n    return self;\n  } // If self is the last item in the parent list, link the lists last item\n  // to the previous item.\n\n\n  if (list.tail === self) {\n    list.tail = prev;\n  } // If self is the first item in the parent list, link the lists first item\n  // to the next item.\n\n\n  if (list.head === self) {\n    list.head = next;\n  } // If both the last and first items in the parent list are the same,\n  // remove the link to the last item.\n\n\n  if (list.tail === list.head) {\n    list.tail = null;\n  } // If a previous item exists, link its next item to selfs next item.\n\n\n  if (prev) {\n    prev.next = next;\n  } // If a next item exists, link its previous item to selfs previous item.\n\n\n  if (next) {\n    next.prev = prev;\n  } // Remove links from self to both the next and previous items, and to the\n  // parent list.\n\n\n  self.prev = self.next = self.list = null; // Return self.\n\n  return self;\n};\n/**\n * Prepends the given item *before* the item operated on.\n * @name ListItem#prepend\n * @param {ListItem} item - The item to prepend.\n * @returns {ListItem} - The item operated on, or false when that item is not\n * attached.\n */\n\n\nListItemPrototype.prepend = function (item) {\n  if (!item || !item.append || !item.prepend || !item.detach) {\n    throw new Error(errorMessage + 'Item#prepend`.');\n  } // Cache self, the parent list, and the previous item.\n\n\n  var self = this,\n      list = self.list,\n      prev = self.prev; // If self is detached, return false.\n\n  if (!list) {\n    return false;\n  } // Detach the prependee.\n\n\n  item.detach(); // If self has a previous item...\n\n  if (prev) {\n    // ...link the prependees previous item, to selfs previous item.\n    item.prev = prev; // ...link the previous items next item, to self.\n\n    prev.next = item;\n  } // Set the prependees next item to self.\n\n\n  item.next = self; // Set the prependees parent list to selfs parent list.\n\n  item.list = list; // Set the previous item of self to the prependee.\n\n  self.prev = item; // If self is the first item in the parent list, link the lists first item\n  // to the prependee.\n\n  if (self === list.head) {\n    list.head = item;\n  } // If the the parent list has no last item, link the lists last item to\n  // self.\n\n\n  if (!list.tail) {\n    list.tail = self;\n  } // Return the prependee.\n\n\n  return item;\n};\n/**\n * Appends the given item *after* the item operated on.\n * @name ListItem#append\n * @param {ListItem} item - The item to append.\n * @returns {ListItem} - The item operated on, or false when that item is not\n * attached.\n */\n\n\nListItemPrototype.append = function (item) {\n  // If item is falsey, return false.\n  if (!item || !item.append || !item.prepend || !item.detach) {\n    throw new Error(errorMessage + 'Item#append`.');\n  } // Cache self, the parent list, and the next item.\n\n\n  var self = this,\n      list = self.list,\n      next = self.next; // If self is detached, return false.\n\n  if (!list) {\n    return false;\n  } // Detach the appendee.\n\n\n  item.detach(); // If self has a next item...\n\n  if (next) {\n    // ...link the appendees next item, to selfs next item.\n    item.next = next; // ...link the next items previous item, to the appendee.\n\n    next.prev = item;\n  } // Set the appendees previous item to self.\n\n\n  item.prev = self; // Set the appendees parent list to selfs parent list.\n\n  item.list = list; // Set the next item of self to the appendee.\n\n  self.next = item; // If the the parent list has no last item or if self is the parent lists\n  // last item, link the lists last item to the appendee.\n\n  if (self === list.tail || !list.tail) {\n    list.tail = item;\n  } // Return the appendee.\n\n\n  return item;\n};\n/**\n * Expose `List`.\n */\n\n\nmodule.exports = List;","map":null,"metadata":{},"sourceType":"script"}